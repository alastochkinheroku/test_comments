/* 
*   БИБЛИОТЕКА ГЕНЕРАТОРА ПАДЕЖЕЙ
*   требует функции 27 релиза библиотек TADS   
*   основная часть -GrAnd, 
*   отдельные моменты - Flint, Fireton
*   Добавление маркеров падежей
*   Использование этого кода не допустимо без согласования с автором
*/

#ifdef GENERATOR_INCLUDED
#else
#define GENERATOR_INCLUDED
#endif

#define _ON		isHim = true
#define _ONA	isHer = true

#define EDINS	        1
#define MNOZH	        2
#define MUZHR	        4
#define ZHENR	        8
#define SREDR	        12
#define SUSHE	        16
#define PRILA	                32
#define ODUSH	        64
// однозначно есть ударение
#define UDARE	        128
// однозначно нет ударения
#define BEZUD	        256
#define BEGGL	        512
// восьмой тип склонения
#define EIGHT	                1024    
#define ISDESC	        2048
#define RETDET	        4096

#define gencomrul generator.commonrules


// ВНЕДРЕНИЕ ГЕНЕРАТОРА В КОД
// после проверки автором, вывод нужно отключить
generation: function
{   
   // вывод только в режиме отладки
#ifdef __DEBUG
   // вывод кода генерации. Закомментировать после проверки
    generator.printout:=true;
   // вывод использованных правил
   // generator.detailed:=true;
#endif
    
    // смотри также флаг _GENDETAILED
   
   generator.start;
}

// ОБРАЗЕЦ ИСПОЛЬЗОВАНИЯ
// Для того, чтобы генератор начал обработку, необходимо включить
// в лексему символ "/". После него могут идти флаги с указанием рода
// и числа, так как они могут отличаться от заданных в объекте.
// "M"(англ) и "М"(русская) - Мужской род
// "F" и  "Ж" - Женский род
// "N" и "С"(рус), а также "МЖ" вместе - Средний род
// "1" - единственное число
// "2" - множественное число. Вместе с 1 не указывать.
// "A"(англ) или "П" - Прилагательное (Adjective)
// "щ" - суЩествительное (Noun) - редко прописывается вручную
// "I" или "О" (русская) - Одушевленный (anImated)
//  Ударное окончание задаётся прописной буквой (или флагами "уд" или "u")
// знак " * " обозначает беглую гласную в окончании.
// флаги можно писать строчными буквами

/*
testobj: item
desc='странный/1мп предмет/1м из иного/п- мира/п-'
adjective = 'плоский/1м'  'акульи/2'
noun='воблы/й' 'крюки/м2' 'рука/1ж' 'вилы/2' 'щепочка/1ж' 'быстрая/п1ж' 'блоха/ж' 'муравьИ/2ом'
isHer=true
isThem=true
;
*/

// Вносим изменения в класс объекта
modify thing
descs=nil
replace sdesc={if (descs) "<<descs[1]>>"; else pass sdesc;}
replace rdesc={if (descs) "<<descs[2]>>"; else pass rdesc;}
replace ddesc={if (descs) "<<descs[3]>>"; else pass ddesc;}
replace vdesc={if (descs) "<<descs[4]>>"; else pass vdesc;}
replace tdesc={if (descs) "<<descs[5]>>"; else pass tdesc;}
replace pdesc={if (descs) "<<descs[6]>>"; else pass pdesc;}
replace mdesc={ if (descs && length(descs)>6) "<<descs[7]>>"; else self.pdesc; }
;

class genobj: object
sdesc="<<descs[1]>>"
rdesc="<<descs[2]>>"
ddesc="<<descs[3]>>"
vdesc="<<descs[4]>>"
tdesc="<<descs[5]>>"
pdesc="<<descs[6]>>"
//mdesc="<<descs[7]>>"
;

//modify fixeditem: genobj
//;

// исправление проблемы с очисткой сгенерированных лексем в версиях до 2.5.14
replace initRestart: function(parm)
{
  global.restarting := true;

#ifndef __DEBUG
     "<<generator.vers>>";
    if (generator.lexemresetfixed<>true)
    {
     "\n\tПожалуйста, подождите, идет генерация падежей.  Версия компилятора - <<generator.compversion>>\n";
     generator.start;
    }
#endif
}

// особо склоняемые слова, правила поЖелезняку
specialwordclass: object
    // разные с ударным окончанием
    alludar= ['u' 'большой|большая|большое']
    // по Зализняку склонение 1*b - выпадающая гласная    
   firstastb = ['*' 'Лев|багор|бугор|вихор|ковёр|козёл|копёр|костёр|котелец|котёл|лев|лоб|лёд|лён|мошна|овен|овёс|орёл|осёл|посол|пёс|ров|рожон|рот|сон|тигролев|торец|угол|узел|хребет|шов|щегол']
   firstaste = ['*' 'ветер']
    
   thirda = ['' 'альпеншток|блок|брелок|войлок|восток|глок|диплодок|док|дрок|едок|ездок|игрок|исток|клок|кок|лжепророк|морок|моноблок|опреснок|отрок|порок|поток|приток|пророк|рок|сок|заскок|седок|срок|ток|урок|челнок|чеснок|ходок|шок|экивок|ярунок']
    // большей частью -ок с выпадающ. "о". Также смотри ниже
    allast = ['*' '.*ок']    
    // все 3*а на -ок
   //thirdasta = ['*' 'барвинок|беспорядок|бочонок|бычок|выводок|выродок|десяток|достаток|жаворонок|желудок|заголовок|загривок|закоулок|замок|заработок|затылок|зимородок|избыток|кубок|набросок|напиток|напёрсток|обносок|обрубок|обрывок|обвесок|огрызок|околоток|окурок|осадок|осколок|остаток|отпечаток|отрезок|оттенок|ошпырок|паводок|пасынок|патрубок|перекресток|перелесок|подарок|подбородок|подзаголовок|подлесок|подонок|подросток|подсвинок|подстенок|полудурок|полустанок|порядок|поступок|поселок|потомок|початок|передок|придурок|прилавок|припадок|поселок|приямок|промежуток|проступок|распадок|рассудок|рисунок|рубанок|рынок|самородок|свиток|слепок|слиток|снимок|список|ублюдок|упадок|участок|хлопок']
   // все 3*b на -ок
   // thirdastb = ['*' 'Василёк|адресок|академгородок|ангелок|бегунок|белок|белёк|браток|брусок|бурдючок|буёк|бычок|варок|василёк|венок|вентилёк|ветерок|вечерок|вилок|висок|виток|гайдучок|глазок|глоток|голубок|городок|горшок|грибок|движок|денёк|желток|жучок|завиток|замок|зверёк|звонок|зга|зевок|кабачок|каток|кипяток|кишка|клинок|клочок|клубок|кобелёк|коготок|кожанок|козелок|козырёк|колобок|колок|колонок|колосок|колпачок|комок|кондачок|конёк|косячок|котелок|кочерга|кошелёк|кружок|крючок']
   //thirdastb1 = ['*' 'кулёк|курок|кусок|ларёк|лепесток|лесок|листок|лобок|малёк|марток|мастерок|мешок|мозжечок|молоток|моток|мотылёк|мох|муженёк|мужичок|мысок|носок|нырок|облучок|огонёк|оселок|островок|парок|пенёк|песок|петушок|платок|плевок|поводок|помазок|порошок|посошок|потолок|прыжок|пузырёк|пупок|пучок|пятачок|пяток|репеёк|рожок|росток|рундучок|рывок|рядок|садок|сачок|силок|скачок|смешок|смычок|снежок|совок|соснячок|сосок|сосунок|станок|стебелёк|стежок|стрелок|сурок|сучок|сынок|творожок|телок|теремок|толчок|тормозок|торчок|туесок|уголок|узелок|флажок|хлопок|хохолок|цветок|чаёк|черепок|черпачок|чугунок|шинок|шлепок|шнурок|шпенёк']
    // р.п. мн. числа следующих слов совпадает с им. п. единственного (1a(2) по Зализняку):
   // firstasecond = ['%' 'алтын|ампер|аршин|байт|башкир|бод|бот|бурят|ваган|гренадер|грузин|гусар|кадет|кирасир|миллиампер|нганасан|плевел|погон|полубайт|румын|сарацин|солдат']
 
    // 5*а - более 1300, все кончаются на суффикс -ец. Добавлять не будем. "а" - значит, основа ударная
   // 5*b - более 80.  ударение на окончание. при склонении в основе происходит чередование гласной "е" с «нулём».
   // часть - самец, свинец, скворец, скопец, скупец, слепец, соистец, солонец, сорванец, сосец, столбец, стрелец 
    fifthastb=['*u' 'Петродворец|Резец|Телец|боец|варенец|вдовец|венец|глупец|голбец|горец|дворец|делец|долгунец|донец|елец|живец|жилец|звонец|зубец|изразец|истец|каганец|козелец|козинец|конец|косец|крестец|купец|ларец|леденец|лизунец|ловец|макрообразец|малец|молодец|наркоделец|образец|оголец|огурец|отец|певец|перепродавец|песец|пипец|писец|плавунец|пловец|погребец|поставец|продавец|птенец|путец|радиосвинец|резец|рубец|рунец|рыбец|самец|светец|свинец|синец|скворец|скопец|скупец|слепец|слопец|соистец|солонец|сорванец|сосец|столбец|стрелец|творец|тунец|удалец|чепец|юнец']
    fifthastbpl=['*u' 'бойцы|вдовцы|венцы|глупцы|голбцы|горцы|дворцы|дельцы|деревца|ельцы|живцы|жильцы|зубцы|изразцы|истцы|концы|крестцы|купцы|ларцы|леденцы|лизунцы|ловцы|мальцы|молодцы|наркодельцы|образцы|огурцы|отцы|певцы|песцы|писцы|плавунцы|пловцы|продавцы|птенцы|резцы|рубцы|самцы|скворцы|скопцы|скупцы|слепцы|слопцы|соистцы|солонцы|сорванцы|сосцы|столбцы|стрельцы|творцы|тунцы|удальцы|чепцы|юнцы']
    fifthbpl=['u' 'багрецы|беглецы|жнецы|жрецы|игрецы|козлецы|кольчецы|кострецы|кузнецы|лжецы|мертвецы|мокрецы|мудрецы|наглецы|орлецы|острецы|подлецы|пошлецы|пришлецы|простецы|спецы|стервецы|хитрецы|храбрецы|чернецы|шельмецы']
    firstdpl=['!u' 'беды|вдовы|величины|веретена|ветчины|вины|вина|войны|волны|высоты|главы|глубины|гнезда|графы|грозы|губы|длины|длинноты|долготы|долота|дупла|дыры|жены|звезды|золы|иглы|игры|избы|икры|кайлы|кислоты|клейма|кобзы|кобуры|козы|колбасы|косы|красоты|крупы|леса|лисы|листы|лозы|луны|меньшинства|муравы|новины|норы|нужды|орды|осы|пастилы|пизды|пилы|плиты|полы|пруты|пустоты|пчелы|решета|росы|сверла|седины|сироты|скопы|скулы|слюды|смолы|совы|среды|старшины|стопы|страны|стрекозы|стрелы|стрельбы    |строфы|струны|тавра|толпы|тошноты|травы|трубы|узды|фрезы|частоты|чела|шизы|ширины|широты|шкалы|ярма']
   //  8e - классическое 3-ье склонение
    // авточасть, бестолочь, боль, бровь, весть, ветвь, вещь, власть, гроздь, десть, должность, дробь, жердь, жопень, запчасть, зыбь, кисть, клеть, кости, кость, крепкость, крепость, кровь, лебедь, масть, матерь, мелочь, мышь, новость, ночь, нощь, область, ость, ось, отрасль, очередь, печь, плоскость, площадь, повесть, подать, подсеть, полоть, полуось, пропасть, речь, роль, сволочь, сельдь, сеть, скатерть, скорбь, скорость, сласть, смерть, снасть, соль, степень, степь, страсть, тень, треть, трость, цепь, часть, челюсть, четверть, шерсть, щель, щёлочь, электроцепь, энергосеть
    eighte=['8' 'авточасти|бестолочи|боли|брови|вести|ветви|вещи|власти|грозди|должности|дроби|жерди|запчасти|зыби|кисти|клети|кости|крепкости|крепости|крови|лебеди|масти|матери|мелочи|мыши|новости|ночи|нощи|области|ости|оси|отрасли|очереди|печи|плоскости|площади|повести|подати|подсети|полоти|полуоси|пропасти|речи|роли|сволочи|сельди|сети|скатерти|скорби|скорости|сласти|смерти|снасти|соли|степени|степи|страсти|тени|трети|трости|цепи|части|челюсти|четверти|шерсти|щели|щёлочи|электроцепи|энергосеть']
    classes = [self.alludar self.firstastb self.firstaste self.thirda self.allast /*self.thirdasta self.thirdastb self.thirdastb1*/ self.fifthastb self.fifthastbpl self.fifthbpl self.firstdpl  self.eighte]
    checkword (word2check) = 
   {
      if (word2check!='' && word2check<>nil)
        {
            local i;
            for (i:=1; i<=length(classes); i++)
            {
                local temp=dezyo(loweru(classes[i][2]));
                // небольшое усложнение схемы позволяет склонять слова через дефис. Типа "ампер-виток"
                if (reSearch('^(.+-)*(не)*(' + classes[i][2] + ')$', word2check)<>nil) 
                    return classes[i][1];
                 if (reSearch('^(.+-)*(не)*(' + temp + ')$', word2check)<>nil) 
                    return classes[i][1];               
            }
        }
   }
;





// ОБЪЕКТ ГЕНЕРАТОРА ПАДЕЖЕЙ
// Хранит правила склонений и содержит необходимые методы
// для массовой и одиночной генерации
generator: object

// выдовать ли на печать результат генерации
printout =nil
    
// вывод меток падежей и занесения в список лексем. 
// Отключается для облегчения проверки орфографии
#ifndef _NOINFO
printout_geninfo=true
#else
printout_geninfo=nil  
#endif

// выводить номера применённых правил
#ifdef _GENDETAILED && _DEBUG
detailed =true
#else
detailed =nil
#endif

// задаем символьные множества
symbols=
    [['0' '[бвдзлмнпрстфц]'] 
    ['1' '[еуюа]'] 
    ['2' '[бвдзлмпрсфц]']
    ['3' '[бвгджзнрц]']                       //звонкие
    ['4' '[чшщц]']                                //шипящие
    ['6' '[бвгджзйклмнпрстфхцчшщ]']     //согласные
    ['8' '[аеёиоуыэюя]']                        //гласные
  ]

// чисто для порядка - именительный
irules = []


// правила для родительного падежа
// требования к грам. свойствам слова, шаблон и схема замены
// числа -символьные множества
// Грам. флаги в правилах - только английские заглавные
// очень непросто с мн. числом: http://www.dofa.ru/open/book/1_russ/u1212.htm
    
rrules =
    [

    ['2F'    'йки'  	'ек']           // батарейки
    ['2F'    '(4|й)ки'  	'$1ек']     // болячки, кусачки, подачки
    ['2F'    '(6)([кг])и'  	'$1о$2']     //6 согл   пробки
    ['2'    'деньги'  	'денег']  // исключение...    
    ['2F'    '(г|к|х)и'   	'$1']
    ['2M'    '(г|к|х)и'   	'$1ов']
    ['2F'    'ли' 	'ль']  // пули и дули   
    // 1a(2) по классификации А. Зализняка. особый только р.п. множественного числа. Все 22 по викисловарю
    ['2'    '(алтын|ампер|аршин|байт|башкир|бод|бот|бурят|ваган|гренадер|грузин|гусар|кадет|кирасир|миллиампер|нганасан|плевел|погон|полубайт|румын|сарацин|солдат)ы'  	'$1']    
    ['28F'   '(6)и'     '$1ей']   // брови - бровей
    ['2FU'   '(4)и'     '$1ей']         // вЕщи->вещЕй, нОчи - ночЕй
    ['2F'    '(4)и'     '$1']	     //     клячи, кучи;  но ."бестолочи","очи"?
    ['2F'    '(6)и' 	'$1']   //руки - женский род 3
    ['2F'    '(6)ы' 	'$1']   //ампулы   - ж.р. 5а
    ['2F'    '(.)ы'  	'$1']
    ['2'     'кна'  	'кон']
    ['2U'    '(8)и' 	'$1ёв']      // боИ  (8- гласные)
    ['2F'    '(8)и'	'$1й']       // стаи, змеи, линии, струи     
    ['2'     'лица'  	'лиц']  // единственный представитель 5d по Зализняку    
    ['2'     '(6)ца'  	'$1ец']	     // коленца
    ['2U'     'цы'  	'цов']	     // подлецы,  стервецы, хитрец и др. 5b 
    ['2'     'цы'  	'цев']	     // архаровцы, эсминцы
    ['2F'    '(6)ли' 	'$1ель']     // капли (6 - согл)
    ['2U'    'ьи'	'ьёв']       // воробьИ, муравьИ
    ['2F'    'ы'  	'']          // соты, лисы (как записать не имеющих ед. числа?)       
    ['2U'    '(4|ж)и'   '$1ей']      // лучИ, ножИ, хлыщИ
    ['2U'    'и|ы'  	'ов']        // пирогИ, слонЫ    
    ['2F'    'ги'   	'г']            //пирОги, ноги
    ['2'     'ги'   	'гов']
  ]


// дательный
drules = []


// винительный
// мужской одушелвенный автоматически приравнивается родительному,
// и поэтому тут не прописывается
vrules =
[
  ['2FI' 'йки'  'ек']	   // канарейки
  ['2FI' '(4)ки'  '$1ек']  // казАчки
  ['2FI' '(0)ки'  '$1ок']  //
  ['2FI'  'ки'   'к']	   // собаки
  //['2I'  'ки'   'ков']     // моряки
  //['2M'    'ки'   'ки']    // крюки
  ['2FI' '(6)ги'  '$1ог']
  ['2FI'  'ги'  'г']
  ['2I'   'ги'   'гов']
  ['2UI' 'ьи' 'ьёв']
  //['1MI' 'ь' 'я']
  ['I'	'ий' 'его']
]


// творительный
trules=
[
   ['1U'  '(4|ж)а' '$1ой']	// U - ударение, 4 - шипящие
   ['1'  '(4|ж)а' '$1ей']
   ['1A'  '(4|ж)ой' '$1им']
   ['1U' '(8[бвгджзйкмнпрстфхцчшщ])ец' '$1цом']
]


// творительный2 - украинизированная или литературная форма
trules2=
[  
  ['1U'	'(4|ж)а'	'$1ою']	//маржою
  ['1'	'(4|ж)а'	'$1ею'] //жижею
  ['1'	'а'	'ою']		//лисою
  [''	'(4|ж)ая'	'$1ею'] //рыжая, куцая
  [''	'ая'	'ою']           //толстая
  [''	'яя'	'ею']           //последняя  
  ['1U' '(6)я'	'$1ёю']           //стезЯ
  ['1F'	'(6)я'	'$1ею']           //пуля
]


// предложный падеж
prules = []

// В разбиении нет особой логики, просто последовательно разделил, чтобы анализируемый
// массив укладывался в заданный по умолчанию размер буфера разборщика 
// Если при добавлении правил будет появляться ошибка, разбейте на меньшие фрагменты

// вид: требования к грам. свойствам слова, шаблон, 5 схем замены для склонений, кроме
// именительного + комментарий (опционально)

commonrules1 =
// Множественное число существительных на -а:
[['2'	'ена'	'ён'	'енам'	'ена'	'енами'	'енах'],  // письмена
['2'	'ёна'	'ён'	'ёнам'	'ёна '	'ёнами'	'ёнах'],  // знамёна
['2'	'(6)на'	'$1ен'	'$1нам'	'$1на'	'$1нами' '$1нах'],  // брёвна, 6 -согл.

['2'	'та'	'т'	'там'	'та'	'тами'	'тах'],     // ребята, (т.ж. ворота,корыта)
['2M'	'а'	'ов'	'ам'	'а'	'ами'	'ах'],     // дома
['2'	'а'	''	'ам'	'а'	'ами'	'ах'],     // гнёзда

[''	'(0)а'  '$1ы'   '$1е'    '$1у'  '$1ой'   '$1е']    //бвдзлмнпрстфц
[''	'а'   'и'    'е'	'у'   'ой'   'е']
]
//8  - количество правил в блоке

commonrules2 = 
// все на -я
[[''	'мя'  'мени' 'мени'  'мя'  'менем' 'мени']   // время
['U'	'(4|ж)ая'  '$1ой' '$1ой'   '$1ую' '$1ой'  '$1ой']     // шипящие и 'ж' + 'ая' с ударением
[''	'(4|ж)ая'  '$1ей' '$1ей'   '$1ую' '$1ей'  '$1ей']     // шипящие и 'ж' + 'ая'
[''	'ая'  'ой'  'ой'  'ую'  'ой'   'ой']     // остальные прил. на -ая']
[''	'яя'   'ей'   'ей'   'юю'   'ей'   'ей']     // прил. на -яя + преисподняя
['2'	'ья'   'ьев'   'ьям'   'ья'   'ьями'   'ьях']   // клочья, перья
['2'	'ия'   'ий'   'иям'   'ия'   'иями'   'иях']  // покрытия
[''	'ия'   'ии'   'ии'   'ию'   'ией'   'ии']  // существительные на -ия
['U'	'я'   'и'   'е'   'ю'   'ёй'   'е']
[''	'я'   'и'   'е'   'ю'   'ей'   'е']
]
// 10

commonrules3 =
// на -й
[['щ'	'ой'   'оя'   'ою'   'ой'   'оем'   'ое']  //ковбой
[''	'ой'   'ого'   'ому'   'ой'   'ым'   'ом']  //злой
[''	'(1)й'   '$1я'   '$1ю'   '$1й'   '$1ем'   '$1е']	// еуюа
[''	'ый'   'ого'   'ому'   'ый'   'ым'   'ом']
['щ'	'ий'   'ия'   'ию'   'ий'   'ием'   'ии']
[''	'(к|г)ий'   '$1ого'   '$1ому'   '$1ий'   '$1им'   '$1ом']  // плоский, пологий
[''	'ий'   'его'   'ему'   'ий'   'им'   'ем']
[''	'й'   'и'   'и'   'й'   'ем'   'е']
]
// 8

commonrules4 =
// на о
[[''	'(6)о'   '$1а'   '$1у'   '$1о'   '$1ом'   '$1е']  // (6 - согл.)
[''	'о'   'о'   'у'   'о'   'ом'   ' е']	
    
// на -е    
[''	'(0)ое'   '$1ого' '$1ому' '$1ое' '$1ым'   '$1ом'] // прил., на тв. согл. (бвдзлмнпрстфц)
[''	'ое'   'ого'   'ому'   'ое'   'им'   'ом'] // прил., на м. согл.
// делимое?
[''	'(е|ё)е'   '$1го'   '$1му'   '$1е'   'им'   'ем']  
['2'	'(и|ы)е' '$1х' '$1м' '$1е' '$1ми' '$1х']
[''	'ие'   'ия'   'ию'   'ие'   'ием'   'ие']  // рвение, бдение
[''	'ье'   'ья'   'ью'   'ье'   'ьем'   'ье']  // раздолье
[''	'ьё'   'ья'   'ью'   'ье'   'ьём'   'ье']  // враньё
[''	'це'   'ца'   'цу'   'це'   'цем'   'це']
['2'	'ые'   'ых'   'ым'   'ые'   'ыми'   'ых']
[''	'(4|ж)е'   '$1а'   '$1у'   '$1е'   '$1ем'   '$1е']      //сердце, чудище, ложе
[''	'([рль])е'   '$1я'   '$1ю'   '$1е'   '$1ем'   '$1е']
]
//13 - 39

commonrules5 =
// -ё
[[''	'(6)ё'   '$1я'   '$1ю'   '$1й'   'ём'   '$1е']
[''	'ё'   'ё'   'ё'   'ё'   'ём'   'е'] 

// на -ь    
['F'	'(мат|доч)ь'   '$1ери'   '$1ери'   '$1ь'   '$1ерью'   '$1ери']   // исключение 8e^ по классификации А. Зализняка
['F'	'ь'   'и'   'и'   'ь'   'ью'   'и']
// беглая гласная "е" и "о"
// -ень,-оть щебень, стержень, ломоть, лапоть, коготь; всего более 30-ти 
// но!!! -олень, тюлень, окунь, пельмень, бюллетень, ясень, ячмень (это почти все)
['M'	'ень'   'ня'   'ню'   'ень'   'нем'   'не']
['M'	'оть'   'тя'   'тю'   'оть'   'тем'   'те']
// Исключения, беглые гласные. Когда-то был огнь, угль и угрь. Угря не ввожу. 
['M'	'огонь'   'огня'   'огню'   'огонь'   'огнём'   'огне']
['M'	'уголь'   'угля'   'углю'   'уголь'   'углём'   'угле']
[''	'ь'   'я'   'ю'   'ь'   'ем'   'е']
]
// 9  - 48

commonrules6 =
// на -и
[['2A'	'ьи'   'ьих'   'ьим'   'ьи'   'ьими'   'ьих']     //козьи
['2F'	'ьи'   'ей'   'ьям'   'ьи'   'ьями'   'ьях']
['2F'	'(4|ж|й)ки' '$1ек'   '$1кам'   '$1ки' '$1ками'   '$1ках']  // (4 - шипящие)
['2F'	'ли'   'ль'   'лям'   'ли'   'лями'   'лях']   // дули

['2'	'(8|ь)и'   '$1ев'   '$1ям'   '$1и'   '$1ями'   '$1ях']  // 8 - гл-ые, ульи 
['2'	'(4|ж)и'   '$1'   '$1ам'   '$1и'   '$1ами'   '$1ах' 'Важно ударение! (р.п.) ']  // тучи, мощи, ножи
['2'	'(0)и'   '$1ей'   '$1ям'   '$1и'   '$1ями'   '$1ях']  // бвдзлмнпрстфц 

['' '^ты' 'тебя' 'тебе' 'тебя' 'тобой' 'тебе']

//гкх. оплеУхи, пирОги, лодки; лОхи->лохОв  (р.п. разный в зав. от рода)
['2'	'и'   'ов'   'ам'   'и'   'ами'   'ах' 'Важно ударение! (р.п.)'] 
// все -ы: болты, блины, курсы, вопросы. Но - лисы, стразы, ножницы, патлы 
    // р.п. мн. числа следующих слов совпадает с им. п. единственного (1a(2) по Зализняку):
    // алтын, ампер, аршин, байт, башкир, бод, бот, бурят, ваган, гренадер, грузин, гусар, кадет, 
    // кирасир, миллиампер, нганасан, плевел, погон, полубайт, румын, сарацин, солдат
['2'	'ы'   'ов'   'ам'   'ы'   'ами'   'ах' 'Важен пол (р.п.)']     
[''	'(и|ы)'   '$1'   '$1'   '$1'   '$1'   '$1']   //Натали, Оглы
]
// 10

commonrules7 =
// -к
// -беглая о (правила составлены перебором по словарю)
// при двойных согласных убегает в -лж, лз, лм, лт, лч, рж, рм, рт, рч, рш
// -сток, кроме Восток, исток, водосток;  в -здок беглая, кроме "ездока" и "диздока".  
    [['*'	'(6)(е|ё)к'   '$1ька'   '$1ьку'   '$1$2к'   '$1ьком'   '$1ьке']
['*'	'(6)(8)к'   '$1ка'   '$1ку'   '$1$2к'   '$1к$2м'   '$1ке']

    
[''	'(8)чек' '$1чка' '$1чку' '$1чек'   '$1чком' '$1чке'] // кусочек, цветочек (8-гласные)
[''	'(8)ёк' '$1йка' '$1йку'   '$1ёк'   '$1йком' '$1йке'] // чаёк, паёк
[''	'ёк'   'ька' 'ьку'   'ёк'   'ьком'   'ьке']  // тенёк

[''	'ёл'   'ла'   'лу'   'ёл'   'лом'   'ле']  // козёл

// -ец
[''	'(а|е|о|и)ец' '$1йца' '$1йцу' '$1ец' '$1йцем' '$1йце']	//молотобоец, олимпиец
[''	'(8)лец' '$1льца' '$1льцу' '$1лец' '$1льцом' '$1льце'] // жилец, но не подлец
// как оказалось, большая часть основ ударная
[''	'(8[бвгджзйкмнпрстфхцчшщ])ец' '$1ца' '$1цу' '$1ец' '$1цем' '$1це' 'Важно ударение (т.п.)!'] 
[''	'заяц'   'зайца'   'зайцу'   'зайца'   'зайцем'   'зайце'] // исключение, однако -яц, но склоняется как -ец

// по Зализняку склонение 1*b - выпадающая гласная
// лёд, лен    
['*'	'л(ё|е)(6)'   'ль$2а'   'ль$2у'   'л$1$2'   'ль$2ом'   'ль$2е']     
// орёл, посол
['*'	'(6)(8)(6)'   '$1$3а'   '$1$3у'   '$1$2$3'   '$1$3ом'   '$1$3е']	

[''	'(6)' '$1а' '$1у' '$1' '$1ом' '$1е']	// -ом/ем после шипящих зависит от ударения
]

// Правила для всех склонений
commonrules = {}

// Правила для отдельных склонений
rules = [self.irules self.rrules self.drules self.vrules self.trules self.prules self.trules2]
    
// Схема для меток сокращений
symtemplate=''

// разбиение на слова списка лексем в одной строке
// 'палка/ брусок/ обломок/' -> 'палка/' 'брусок/' 'обломок/'
breakup(str)=
{
 local res=nil, lexems=[], lc=0, counter=0;
 
 while (res:=reSearch('([-_&@ёЁa-zA-Zа-яА-Я0-9]+/[-_ёЁa-zA-Zа-яА-Я0-9+]*)([ ,.;]*)',str), res<>nil && 
 ((counter=0 && reGetGroup(2)[2]>0) || counter>0)) 
 {
   lexems+=reGetGroup(1)[3];
   lc++;

   if (length(str)>res[1]+res[2]) 
     str:=substr(str,res[1]+res[2],length(str));
   else break;
   
   counter++;
 }
 if (lc=0) return nil;
 else return [lexems, lc]; 
}

// ЗАПУСК ГЕНЕРАТОРА
// ищем все слова и генерируем склонения
// если передали nil, то подготовить генератор, но не 
// проводить массовой генерации
start(...) =
{
    local obj, i, j, gencnt=0, makeitall:=true;
    local ftime:=gettime(GETTIME_TICKS);
    
    if (argcount>0 && getarg(1)=nil) makeitall:=nil;
    
    // проверяем, какой версией интерпретатора пользуется автор. Если после 2.5.14,
    // то компилер без ошибки сброса генерации
    if (global.restarting<>true && systemInfo(__SYSINFO_SYSINFO) = true)
   {
       local curver = systemInfo(__SYSINFO_VERSION);
       local temp;

       curver:=replaceStr(curver, '([0-9]).([0-9]).([0-9]+)', '$1$2.$3'); 
       temp:=substr(curver, find(curver, '.')+1, length(curver));
       if (length(temp)=1) temp:='0'+temp;
      curver:=replaceStr(curver, '([0-9]+).([0-9]+)' ,'$1'+temp);
      if (cvtnum(curver)>=2514)
        generator.lexemresetfixed:=true;

      generator.compversion:=curver; "Версия компилятора - <<curver>>";
   }
    
   // Формируем шаблон быстрой проверки наличия символьного множества
   symtemplate:='(';
     
   for (i:=1; i<=length(symbols); i++) 
   {
    symtemplate+=symbols[i][1]; 
    if (i!=length(symbols)) symtemplate+='|';
   }
   symtemplate+=')';
    
  // Формируем правила из фрагментов
  commonrules := commonrules1+commonrules2+commonrules3+commonrules4+commonrules5+commonrules6+commonrules7;
  
  // перерабатываем правила с учетом шаблонов
  // приводим лексические флаги правил к двоичной форме
  for (i:=1; i<=length(commonrules); i++)
  {
        commonrules[i][2]:=generator.replacesym(commonrules[i][2]); 
        commonrules[i][1]:=generator.binarize(commonrules[i][1]);
  }
  for (j:=1; j<=length(rules); j++)    
    for (i:=1; i<=length(rules[j]); i++)
    {
      rules[j][i][2]:=generator.replacesym(rules[j][i][2]);  
      rules[j][i][1]:=generator.binarize(rules[j][i][1]);   
    }
  if (!makeitall) return;  
  
   // Склоняем все, что с пометкой   
   if (printout) "\nВывод сгенерированных лексем. Виден только в режиме отладки. Для полного отключения обнулите флаг printout у объекта generator. \n
 Пояснение: \"1\" - ед. ч., \"2\" - мн. ч.; \"м\" -муж. р., \"ж\" - жен.р., \"с\" - ср. р., \"щ\" - сущ-ое, \"п\" -прил-ое, \"у\" - ударн. ок-ние, \"!у\" - уд. на основе, \"*\" -выпад. гл. в ок-нии.  \n
 Перед \"/\" -  учтенные свойства объекта. (-) - повтор. (#d)(#t) - добавлены лексемы с метками падежей. \n
Директива #define _GENDETAILED  отобразит номера использованных правил.  Первое число - блок правил (1-отдельно падеж, 2- общий, 3- дубль р.п.), второе - порядковый номер.\n
Директива #define _NOINFO позволит выводить результат без доп. инф-ции для проверки орфографии авт-ми средствами.\b
Если окончание формируется неправильно, обратите внимание на пол, число и ударение, особенно, 
 если после вывода есть предупреждение. При простановке ударения учтите, что оно может 
 перемещаться при склонении (огурЕц-огурцА). В таких случаях обозначайте ударение меткой \"у\" или заглавной последней согласной (огуреЦ).\b";
    
    obj := firstobj();
    while (obj <> nil)
    {
      local sdescstr, generated=nil;
      local i=nil, nouns, adjs;
      local nl,al;
      
      // СКЛОНЯЕМ КОРОТКИЕ ОПИСАНИЯ (DESC)
      sdescstr:=obj.desc;
      
      if (sdescstr<>nil) i:=find(sdescstr,'/');
      
      // проверяем, что слеш не из тэга html
      if (i<>nil && !(i>1 && substr(sdescstr,i-1,1)='<'))
      {
         local ret, sdesc_list=[], flags_list=[], result=['' '' '' '' '' ''];
         local wasnoun=nil, wasprep=nil;
         
         // НАРЕЗАЕМ НА ОТДЕЛЬНЫЕ СЛОВА В СПИСОК SDESC_LIST
         // буква ё(Ё) не входит в диапазон а-я(А-Я) 
         while (ret:=reSearch('([/$&@№~%ёЁ_+*#a-zA-Zа-яА-Я0-9-]+)|([][<>()!{}.,;"?\ ]+)', sdescstr), ret<>nil) 
         {
           local   ret1;
           sdesc_list+=ret[3];
           
           //ищем и запоминаем флаги для каждого слова
           if (ret1:=reSearch('.+/(.*)',ret[3]), ret1<>nil) 
              flags_list+=reGetGroup(1)[3];
           else
           {
             // проверка на предлоги 
           	local preps='^(в|во|для|до|из|к|на|о|об|от|при|по|про|с|со)$';
                if (ret1:=reSearch(preps,ret[3]), ret1<>nil)
                    flags_list+='+';
           	else // нужно ли?
           	flags_list+=nil;
           }
              
           sdescstr:=substr(sdescstr,ret[1]+ret[2],length(sdescstr)); 
         }
         
         // ПРОХОДИМ ПО СПИСКУ СЛОВ И СКЛОНЯЕМ ПО НЕОБХОДИМОСТИ
         for (i:=1; i<=length(sdesc_list); i++)
         {
             local j, temp;
             
             if (flags_list[i]<>nil && flags_list[i]<>'+')
             {              
                 //ПРОВЕРЯЕМ НАЛИЧИЕ ФЛАГА ПОЛА И ЧИСЛА У ОБЪЕКТА
                 if ((obj.isHim || obj.isHer || obj.isThem)<>true)
                 {
                   if (reSearch('[mм]',flags_list[i])<>nil) obj.isHim:=true;
                   if (reSearch('[жf]',flags_list[i])<>nil) obj.isHer:=true;
                   if (find(flags_list[i],'2')<>nil) obj.isThem:=true;
                 }
                 
                 // НАЗНАЧАЕМ СВОЙСТВА В ЗАВИСИМОСТИ ОТ МЕСТОРАСПОЛОЖЕНИЯ В СТРОКЕ
                 if (reSearch('[пaу]',flags_list[i])=nil) 
                 {
                 	// существительное было, это прилагательное в род. падеже
                 	if (wasnoun) flags_list[i]+='п-';
                 	else
                 	// если следом предлог или несклоняемое - это существительное
                 	if (i<length(sdesc_list) && (flags_list[i+1]<>nil && reSearch('[+-]',flags_list[i+1])<>nil))
                 		{	
                 		  flags_list[i]+='щ';
                 		  wasnoun:=true;
                 		}
                 	else
                 	// если последнее слово в фразе - существительное
                 	if (i=length(sdesc_list))
                 		{ 
                 		  flags_list[i]+='щ';
                 		  wasnoun:=true;
                 		}
                 	else
                 	// существительного не было, это прилагательное
                 	flags_list[i]+='п';
                 }
                 
             	 // ПРОВЕРЯЕМ, НУЖНО ЛИ ГЕНЕРИРОВАТЬ ПАДЕЖИ
                 if (find(flags_list[i],'-')=nil)
                 {
                   local flags;
                        
                   flags:=generator.binarize(flags_list[i]);
                   temp:=generate(obj, sdesc_list[i], 0, ISDESC | RETDET| flags);   
                   for (j:=1; j<=6; j++) result[j]:=result[j]+temp[j][1];
 
				   //учтем местный  падеж 
				   if (length(temp)>6 && temp[7]!=0 && temp[7]!='') 
                   {
                      if (length(result)<7) result+=temp[7][1];                   
                      else result[7]:=result[7]+temp[7][1];
                   }
                
                   if (!generated) generated:=true;
                   
                   // добавляем лексему с метками для дальнейшей обработки
                   // переписать с учетом структуры предложения!
                   if (find(flags_list[i],'п')<>nil || find(flags_list[i],'a')<>nil)
                    addword(obj, &adjective, sdesc_list[i]);
                   else
                    addword(obj, &noun, sdesc_list[i]);               
                 }
		// ГЕНЕРИРОВАТЬ ПАДЕЖИ НЕ НУЖНО
                else
                 {
                    for (j:=1; j<=6; j++) 
                      result[j]:=result[j]+replaceStr(sdesc_list[i],'(.+)/.+$','$1');
                    
                    // переписать с учетом структуры предложения!
                    if (find(flags_list[i],'п')<>nil || find(flags_list[i],'a')<>nil)
                    addword(obj, &adjective, replaceStr(sdesc_list[i],'(.+)/.+$','$1')); 
                    else
                    addword(obj, &noun, replaceStr(sdesc_list[i],'(.+)/.+$','$1')); 
                 }
             }
             else 
               for (j:=1; j<=6; j++) result[j]:=result[j]+sdesc_list[i];

          }
          
            result-='';
            
          //отчет
          if (generated) 
          {  
           obj.descs:=result;
          
#ifdef __DEBUG
           if (printout)
           {
            // выводим реальные значения склонения
            local padezhi=[&sdesc, &rdesc, &ddesc, &vdesc, &tdesc, &pdesc, &mdesc];
            for (i:=1; i<=6; i++) "\"<<obj.(padezhi[i])>>\" ";
             if (length(obj.descs)=7) "\"<<obj.(padezhi[7])>>\" ";
            "\n";
           }
#endif
          }
      }
      
      // проводим реквизит лексических свойств
      nouns:= getwords(obj,&noun);
      adjs:= getwords(obj,&adjective);
      nl:=length(nouns);
      al:=length(adjs);
      
      
      //СКЛОНЯЕМ СУЩЕСТВИТЕЛЬНЫЕ
      for (i:=1; i<=nl; ++i)
      {
        local res=nil, sklon, temp;
        
        if (find(nouns[i],'/')) 
        {
          // делаем маленькую паузу для выводов результатов
          // при большом количестве генерация может затянуться, и поэтому лучше 
          // выдовать результат понемногу или предупредить игрока        
          if (gencnt%20=1) inputevent(1);
          
          // проверяем, нужно ли разбить лексему на отдельные части
          // 'палка/ брусок/ обломок/' -> 'палка/' 'брусок/' 'обломок/'
          // результат закинет в конец списка!
          while (temp:=self.breakup(nouns[i]), temp<>nil)
          {
           nouns-=nouns[i]; 
           nouns+=temp[1];
           nl+=temp[2]-1;
           //if (i!=1) i--;
          }      
          
          // перебираем склонения
           
          res:=generate(obj, nouns[i], 0, SUSHE|RETDET);
          
          for (sklon:=1; res<>nil && sklon<=length(res); ++sklon)
          if (res[sklon][3][1]!=0)
          {
           local same:=nil;
           local new_nouns:= getwords(obj, &noun);   
           
           // обезъЁживаем
           res[sklon][1]:=dezyo(res[sklon][1]);       
           
           // пополняем список лексем
           if (find(new_nouns,res[sklon][1])=nil) addword(obj, &noun, res[sklon][1]);
           else same:=true;
           
           // вносим лексемы с метками
		   if (sklon=1) addword(obj,&noun,res[sklon][1]+'#i');
		   if (sklon=2) addword(obj,&noun,res[sklon][1]+'#r');
           if (sklon=3) addword(obj,&noun,res[sklon][1]+'#d');
		   if (sklon=4) addword(obj,&noun,res[sklon][1]+'#v');
           if (sklon=5) addword(obj,&noun,res[sklon][1]+'#t');
           if (sklon=7 && find(new_nouns,res[sklon][1])=nil) addword(obj, &noun, res[sklon][1]+'#t');
           
           // вывод информации о результате
           if (printout) 
           {
             if (sklon=1 && res[sklon][2]) 
             {
               "\n";
               // если исползовались свойства объекта, выводим их
               if ((res[sklon][2])!=0) 
                { 
                  (obj.isThem)?"2":"1";
                  if (obj.gender=3) "С";
                  else (obj.gender=1)?"М":"Ж";
                  "/";
                } 
                "<<self.debinarize(res[sklon][2])>>\t- ";
             }
             "<<res[sklon][1]>>";
                        
             if (printout_geninfo)
             {
                " (";
                if (same) "-";
                if (sklon=1) "#i";
                if (sklon=2) "#r";
                if (sklon=3) "#d";
                if (sklon=5) "#t";
                if (sklon=6) "#v";
                if (sklon=7 && find(new_nouns,res[sklon][1])=nil)  "#t";
		")"; 
             }      
             if (detailed && printout_geninfo && res[sklon][3] && sklon!=1) "(<<res[sklon][3][1]>>-<<res[sklon][3][2]>>)";                    
             "\t";

           }  // if
        }  // for
        if (res<>nil) gencnt++;
        if (printout && res[length(res)][3][1]=0) 	" - <<res[length(res)][1]>>";
        if (printout) "\n";
       }
      }
      
      // СКЛОНЯЕМ ПРИЛАГАТЕЛЬНЫЕ
      for (i:=1; i<=al; ++i)
      {
        local res=nil, sklon, temp;
            
        // находим     
        // расчленяем слитные списки            
        if (find(adjs[i],'/'))
        {
            while (temp:=self.breakup(adjs[i]), temp<>nil)
              {
               adjs-=adjs[i]; 
               adjs+=temp[1];
               al+=temp[2]-1;
              }      
                
          // генерируем
          res:=generate(obj, adjs[i], 0, PRILA|RETDET);
          
          for (sklon:=1; res<>nil && sklon<=length(res); ++sklon)
          {
           local same:=nil;
           local new_adjs:= getwords(obj, &adjective);          
            
           // обезъЁживаем         
           res[sklon][1]:=dezyo(res[sklon][1]);  
           
           if (find(new_adjs, res[sklon][1])=nil) 
                addword(obj, &adjective, res[sklon][1]);
           else 
                same:=true;

           
           // вносим лексемы с метками
		   if (sklon=1) addword(obj,&adjective,res[sklon][1]+'#i');
		   if (sklon=2) addword(obj,&adjective,res[sklon][1]+'#r');
           if (sklon=3) addword(obj,&adjective,res[sklon][1]+'#d');
		   if (sklon=4) addword(obj,&adjective,res[sklon][1]+'#v');
           if (sklon=5) addword(obj,&adjective,res[sklon][1]+'#t');
           if (sklon=7 && find(new_adjs, res[sklon][1])=nil) addword(obj, &adjective, res[sklon][1]+'#t');
           
           // вывод информации о результате
           if (printout) 
           {
             if (sklon=1  && res[sklon][2]) 
             {
               "\n";
               if ((res[sklon][2])!=0)
                { 
                  (obj.isThem)?"2":"1";
                  if (obj.gender=3) "С";
                  else (obj.gender=1)?"М":"Ж";
                  "/";
                }
               "<<self.debinarize(res[sklon][2])>> \t- ";
             }
             "<<res[sklon][1]>>";
                        
              if (printout_geninfo)
             {
                " (";
                 if (same) "-";
                 if (sklon=1) "#i";
                 if (sklon=2) "#r";
                 if (sklon=3) "#d";
                 if (sklon=5) "#t";
                 if (sklon=6) "#v";
                 if (sklon=7 && find(new_adjs, res[sklon][1])=nil)  "#t";
                 ")";
              }
              if (detailed && printout_geninfo && res[sklon][3] && sklon!=1) "(<<res[sklon][3][1]>>-<<res[sklon][3][2]>>)"; 
               "\t";

           } // if
          } // for
          if (res<>nil) gencnt++;
        }
        
        if (printout) "\n";
      }
      obj := nextobj(obj);
    }
     if (printout) "\b\b";
     else clearscreen(); 
     if (printout) 
     "\nСлов: <<gencnt>>\nГенерация заняла: <<gettime(GETTIME_TICKS)-ftime>> млс.\n";
}

// задумка преобразовать грамматически флаги в бинарный формат
binarize(str) =
{
	local result=0;
    
        if (datatype(str)=DTY_NUMBER) return str;
	
	if (reSearch('1',str)<>nil) result|=EDINS;
	else // если указаны оба 1 и 2, то 1
	if (reSearch('2',str)<>nil) result|=MNOZH;
    
        if (reSearch('8',str)<>nil) 
            result|=EIGHT;
	
	if (reSearch('M|m|м',str)<>nil) result|=MUZHR;
	if (reSearch('F|f|ж',str)<>nil) result|=ZHENR;
	if (reSearch('N|n|с',str)<>nil) result|=SREDR;
	
	if (reSearch('щ',str)<>nil) result|=SUSHE;
	else // по умолчанию существительное
	if (reSearch('A|a|п',str)<>nil) result|=PRILA;
	
	if (reSearch('I|i|о',str)<>nil) result|=ODUSH;
        if (reSearch('U|u|у|д',str)<>nil) result|=UDARE;
    
        if (reSearch('*',str)<>nil) result|=BEGGL;
	
	return result;
}

debinarize(code) =
{
    local str='';
    
    if (code&EDINS) str+='1';
    if (code&MNOZH) str+='2';
    if (code&EIGHT) 
        str+='8';
    
    if ((code&SREDR)=SREDR) str+='c';
    else
        if (code&MUZHR) str+='м';
        else
            if (code&ZHENR) str+='ж';
    
    if (code&ODUSH) str+='о';
    
    if (code&BEZUD) str+='!у';
    else
    if (code&UDARE) str+='у';
    
    if (code&SUSHE) str+='щ';
    if (code&PRILA) str+='п';
    if (code&BEGGL) str+='*';
    
    return str;
}

// ФУНКЦИЯ ПРОВЕРКИ СООТВЕСТВИЯ ПРАВИЛ  ЗАДАННЫМ КЛЮЧАМ И СВОЙСТВАМ ОБЪЕКТА
check(obj, rules, info) =
{    
    //TODO: определять одушевленность по классу объекта
    
    
    if (datatype(info)!=DTY_NUMBER) 
        info:=self.binarize(info);
    
    // проверка требований к ударению UDARE=128
    if (((rules&UDARE)!=0 && (info&UDARE) && (info&BEZUD)!=0)=0)  return true;    
    
   // Проверяем соотвествие существительного/прилагательного
    if ((rules&PRILA)!=0 && (info&SUSHE)!=0) return true;
    if ((rules&SUSHE)!=0 && (info&PRILA)!=0) return true;
    if ((rules&ODUSH)!=0 && (info&ODUSH)=0) return true;     
    
    // принадлежность 8-ому типу склонения
    if ((rules&EIGHT)!=0 && (info&EIGHT)=0) return true;   
      
   // Если в правилах указан муж. или жен. пол
   if ((rules&SREDR)!=0)
   {
   // Если заданы ключи в слове, не ориентироваться на свойства объекта
     if ((info&SREDR)!=0) 
     {
         if ((info&SREDR)!=(rules&SREDR)) return true;
     }
     else
     {
      if ((obj.isHer && (rules&SREDR)!=ZHENR) || (obj.isHim && (rules&SREDR)!=MUZHR)) return true;
      //  Если в правилах указан средний род      
      if ((obj.isHer && obj.isHim) && (rules&SREDR)!=SREDR) return true;
      if ((!obj.isHer && !obj.isHim) && (rules&SREDR)!=SREDR) return true;
     }
   }

   // если в правиле множественное число
   if ((rules&MNOZH)!=0)
    {
       if ((info&(EDINS|MNOZH))!=0)
        {
            if ((info&EDINS)=EDINS) return true;
        }
     else 
       if (!obj.isThem) return true;
    }
     
    // если в правиле единственное 
   if ((rules&EDINS)!=0)
    {
     if ((info&(EDINS|MNOZH))!=0)
        {
           if ((info&MNOZH)!=0) return true;
        }
        else
           if (obj.isThem) return true;
    }
    
    if ((rules&BEGGL)!=0)
    {
        if ((info&BEGGL)=0)
            return true;
    }
     
    return nil;
}

// ЗАМЕНА СИМВОЛА НА ШАБЛОН
replacesym(str)=
{
    local pattern;
     // проверяем наличие кода символьного множества
    if (reSearch(symtemplate,str)) 
    {
     local c, res;
     for (c:=1; c<=length(symbols); c++)
     {
       res:=reSearch(symbols[c][1],str);
       if (res)  
         // меняем шаблон с учетом символьного множества
         str:=replaceStr(str, symbols[c][1], symbols[c][2]); 
     }
    }
    
    return str;
}
;


// ФУНКЦИЯ СКЛОНЕНИЯ
// Принимает как аргументы: объект, строку для склонения, номер склонения
// (от 0 до 8; 7 - второй творительный, 8 - местный), бинарный флаг части 
// речи [сущ - по умолчанию],  флаг возврата информации о граматических 
// свойствах слова [не возвращает по умолч.], флаг "лексема или описание" 
generate: function(obj, str, sklonenie, ...)
{
  local i, result=[], info, info_str='', udarenie, startsklon, finalsklon, found_rule;
  local gr_type=SUSHE, isdesc=0, return_det=1, orig_sklonenie=sklonenie;
  
  if (argcount=4 && datatype(getarg(4))=DTY_NUMBER) 
    {
        gr_type:=(getarg(4)&(SUSHE|PRILA));
        return_det:=(getarg(4)&RETDET);
        isdesc:=(getarg(4)&ISDESC);
    }
  
  if (sklonenie>8) sklonenie:=1;
  
  // Подстрахуемся на случай использования без запуски движка
  if (generator.symtemplate='') generator.start(nil); 

  // ищем метку и отделяем ключи от слова
  i:=find(str,'/');
  if (i) 
  {
    info_str:=substr(str,i+1,length(str));
    str:=substr(str,1,i-1);
  }

  i:=0; 

  info_str:=lowerru(info_str);
  info:=generator.binarize(info_str); 
    
  // ставим пометку сУщ или Прил
  if ((info&(SUSHE|PRILA))=0)
  {  
        if (gr_type&PRILA) info|=PRILA; 
        else info|=SUSHE;
  }
   
    // TODO: ?
    if (str=nil || str='') return;
   
  // проверяем наличие ударения на окончании
  // указано прописной буквой
    // (строчные)(прописаная гласная)(только строчные гласные). -Ая
    if (reSearch('^[^А-ЯЁ]*[АЕЁИОУЫЭЮЯ][аеёиоуыэюя]*$',str)) 
      info|=UDARE;
    else 
    // выделена согласная -последняя буква в слове, что обозначает
    // ударение, переходящее с основы на окончание при склонении
    if (reSearch('^[^АЕЁИОУЫЭЮЯ]+[БВГДЖЗЙКЛМНПРСТФХЧЦШЩ]$',str)) 
      info|=UDARE;           
    else 
    // единственная гласная в окончании. -дно, ржа
    if (reSearch('^[^аеёиоуыэюя]+[аеёиоуыэюя]$',str)) 
      info|=UDARE;

    // Если лексема, уменьшаем слово целиком
    if (isdesc=0)  str:=lowerru(str);
    else 
    // Если описание с ударением, то уменьшаем только последние две буквы
    if ((info&UDARE)!=0) str:=lower2x(str);
    
  // проверим наличие особого класса склонения 
  { 
    local chwdres:=specialwordclass.checkword(str);
    if (chwdres<>nil)    
    {
        if (find(chwdres,'*')<>nil) info|=BEGGL;
            
        if (find(chwdres,'!u')<>nil) info|=BEZUD;    
            else
        if (find(chwdres,'u')<>nil) info|=UDARE;
                        else
        if (find(chwdres,'8')<>nil) info|=EIGHT;
     }
  }
   
  // если вместо склонения задан 0 - проходим по всем, иначе - только одно
  if (sklonenie=0) 
  {
    startsklon:=1; 
    finalsklon:=8;
  }
  else
  {
    startsklon:=sklonenie;
    finalsklon:=sklonenie; 
    if (!return_det) result:='';
  }

    
  // Цикл по склонениям 
   // только если в строке есть специальный флаг,
  for (sklonenie:=startsklon; sklonenie<=finalsklon && (info<>nil); sklonenie++)
  {  
       local ind_rules_applied=nil; 
       
       // ИНДИВИДУАЛЬНЫЕ ПРАВИЛА СКЛОНЕНИЙ
       // для винительного: 
       // если одушевленный муж. род ед. числа или оба рода множественного, то просто приравниваем родительному
       if (sklonenie=4 && found_rule)
       {
         if (generator.check(obj, ODUSH|EDINS|MUZHR, info)<>true || generator.check(obj, ODUSH|MNOZH, info)<>true) 
         {     
                local temp_result:= result[2][1];

          if (return_det) 
            result += [[temp_result info [3 1]]];
          else result +=  temp_result;   
          
          ind_rules_applied:=true;         
         }
       }
       
       // если местный падеж, то проверяем список исключений
       if (sklonenie=8 && found_rule && isdesc) 
       { 
          if (generator.check(obj, EDINS|MUZHR, info)<>true)
          {
            // источник исключений: http://rusgram.narod.ru/1173-1193.html
            // абстрактные: бред, плен, тыл, хмель, шрифт
            local exceptions:='(ад|бал|берег|бой|бок|бор|борт|вал|воз|глаз|год|горб|гроб|зоб|кол|край|лёд|лес|лоб|луг|мел|мозг|низ|нос|паз|пар|пах|плац|пол|полк|порт|пост|пот|пруд|пух|рай|ров|сад|след|снег|стог|сук|строй|торг|форт|шкаф|яр|Дон|Клин|Крым)';
            local res:=reSearch('^'+exceptions+'$',str);
            if (res<>nil) 
            {
          	  local temp_result:= replaceStr( str, gencomrul[found_rule][2]+'$', gencomrul[found_rule][4]);
	          if (return_det) 
	            result += [[temp_result info [2 found_rule]]];
	          else result +=  temp_result; 
            }  
                    
          }
          else result += 0;
          
          // нечего искать местный падеж где-то ещё
          ind_rules_applied:=true; 
       }
       
       //остальные случаи особенных склонений
       if ((sklonenie>1 && sklonenie<8) && !(sklonenie=7 && isdesc!=0))
       // входим в цикл по списку индивидуальных правил
       for (i:=1; i<=length(generator.rules[sklonenie]) && ind_rules_applied=nil; i++)	
       {
           local replacement='', pattern, res;
           	  
           if (generator.check(obj, generator.rules[sklonenie][i][1], info)) continue;
           
           pattern:=generator.rules[sklonenie][i][2];
        
           // проверяем соответствие шаблону
           res:=reSearch(pattern+'$',str);
           if (res)
           { 
             local temp_result;
             temp_result:=    replaceStr(str,pattern+'$',generator.rules[sklonenie][i][3]);
             
             if (return_det) 
               result += [[temp_result info [1 i]]];
             else result +=  temp_result;
             
             ind_rules_applied:=true;
            }
       }
       
        // ОБЩИЕ ПРАВИЛА СКЛОНЕНИЙ
       // Если по индивидуальным правилам изменений не произвдено, а
       //  склонение не альтернативный творительный, переходим к общим
       if (!ind_rules_applied && sklonenie<7)
       {
             local temp_result='';
            // ранее уже нашли правило
            if (found_rule) 
            {     
               temp_result:=    replaceStr(str,gencomrul[found_rule][2]+'$',gencomrul[found_rule][sklonenie+1]);
 
               if (return_det) 
                 result += [[temp_result info [2 found_rule]]];
               else 
                 result +=  temp_result;            
            }
            else
            // ищем правило, входим в цикл по списку правил 
            for (i:=1; i<=length(gencomrul) && found_rule=nil; i++)	
            {
              local replacement='', pattern, res, gender=nil;
              
              if (generator.check(obj, gencomrul[i][1], info)) continue;
           	  
              pattern:=gencomrul[i][2];
           
              // проверяем соответствие шаблону
              res:=reSearch(pattern+'$',str);
              if (res)
              { 
                 if (sklonenie!=1)
                    temp_result:=    replaceStr(str,pattern+'$',gencomrul[i][sklonenie+1]);
                 else 
                    temp_result:=str;
     
                    if (return_det) 
                      result += [[temp_result info [2 i]]];
                    else 
                       result +=  temp_result;
                                
                 // запоминаем найденное правило               
                 found_rule:=i;
               }
             }
         }
   } 

  // несклоняемое?
  if (result=[]) 
    {
        if (orig_sklonenie=0) result:=[[str 0 [0 0]] [str 0 [0 0]] [str 0 [0 0]] [str 0 [0 0]] [str 0 [0 0]] [str 0 [0 0]]];
        else  result:=[str];
    } 
  else
  if (result=nil) result:=str; else
  // если нашли в правиле сообщение
  if (found_rule && length(gencomrul[found_rule])=8) 
  {
    local temp:=gencomrul[found_rule][8];
    // даем нули вместо информации, чтобы отличать от правил
    result+=[[temp '0' [0 0]]];
  }
    
  return result;
}


//Flint added this
//функция динамически добавляет слово к объекту, генерируя все необходимые падежи
addwordru: function(obj, type, word)
{
	if ( find(word, '/') )
	{
		local gtflag, sklon, res;
		
		if (type = &adjective) gtflag := PRILA;
		else gtflag := SUSHE;
		
		res := generate(obj, word, 0,  gtflag | RETDET);
          
		for (sklon := 1; res <> nil && sklon <= length(res); ++sklon)
		{
			local new_words := getwords(obj, type);
			
			generator.addLexemes(obj, res, type, sklon, new_words);
		}
	}
	else
	{
		addword(obj, type, word);
	}
}

delwordru: function(obj, type, word)
{
	if ( find(word, '/') )
	{
		local gtflag, sklon, res;
		
		if (type = &adjective) gtflag := PRILA;
		else gtflag := SUSHE;
		
		res := generate(obj, word, 0, gtflag | RETDET);
          
		for (sklon := 1; res <> nil && sklon <= length(res); ++sklon)
		{
			delword(obj, type, res[sklon][1]);
			
			if (sklon=3) delword(obj, type, res[sklon][1]+'#d');
			if (sklon=5 || sklon = 7) delword(obj, type, res[sklon][1]+'#t');
		}		
	}
	else
	{
		delword(obj, type, word);
	}
}

// Уменьшает две последние буквы строки
lower2x: function(str)
{
  local strlen=length(str);
  
  if (strlen>2) return substr(str,1,strlen-2)+loweru(substr(str,strlen-1,strlen));
  
  return str;
}